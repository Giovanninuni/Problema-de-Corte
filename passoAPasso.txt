Texto pelo Gemini:

explicacao_problema_corte.txt
---------------------------------------------------------------------

Com base no documento que você forneceu, aqui está uma explicação passo a passo do método usado para resolver o problema de corte de estoque:

### O Objetivo do Problema

O objetivo é descobrir a melhor forma de cortar objetos grandes disponíveis em estoque (como barras de metal ou rolos de papel) em itens menores, com o objetivo de atender a uma demanda específica (um número necessário de cada item) e, ao mesmo tempo, minimizar o desperdício ou o número total de objetos de estoque utilizados.

---

### Passo 1: Formular o Problema (A Dificuldade Inicial)

* O problema é primeiro formulado como um "problema de otimização linear inteiro".
* Isso significa que o objetivo é encontrar o número de vezes (x_j) que cada "padrão de corte" (a_j) deve ser usado para atender exatamente à demanda (d).
* O grande desafio: O número de *todos* os padrões de corte possíveis (n) pode ser gigantesco, na casa dos milhões. É computacionalmente inviável listar todos eles para resolver o problema diretamente.

### Passo 2: A Solução Principal (Simplex com Geração de Colunas)

* Para contornar o desafio do "Passo 1", o método não tenta listar todas as colunas (padrões de corte) de uma vez.
* Em vez disso, ele usa um processo chamado Geração de Colunas.
* Ele começa com apenas alguns padrões de corte básicos (como padrões "homogêneos", que produzem apenas um tipo de item).
* O método "relaxa" o problema, permitindo temporariamente que as soluções sejam fracionárias (por exemplo, "usar o padrão A 3,5 vezes").
* O método Simplex então, iterativamente, *gera* apenas o próximo padrão de corte *mais útil* para adicionar à solução, em vez de conhecer todos eles desde o início.

### Passo 3: Encontrando o "Melhor" Novo Padrão (O Subproblema)

* Para que o "Passo 2" funcione, o algoritmo precisa, em cada iteração, encontrar o novo padrão de corte mais eficiente para adicionar.
* Encontrar esse "melhor" padrão é, na verdade, um problema de otimização separado, conhecido como o Problema da Mochila (Knapsack Problem).
* O Problema da Mochila, neste contexto, é: Qual combinação de itens (a_i) pode ser cortada de *um* objeto de estoque (respeitando o comprimento máximo L) que traga o maior "valor" (maximizando g(a) = soma(lambda_i * a_i)) para a solução atual do Simplex?.
* O documento usa um algoritmo de "Enumeração Implícita" para resolver este Problema da Mochila em cada etapa.

### Passo 4: Resolvendo os Sistemas Lineares (A Ferramenta)

* Durante o processo do Simplex (Passo 2), o algoritmo precisa resolver repetidamente sistemas de equações lineares para encontrar a solução atual (Bx = d) e as variáveis duais (B_transposta * lambda = c_B).
* Para fazer isso de forma eficiente, o método descrito no projeto utiliza a Fatoração LU.

### Passo 5: Obtendo uma Solução Real (A Heurística Residual)

* O "Passo 2" fornece uma solução ótima, mas fracionária (ex: x = (1.33, 2.66, 3.5)). Isso não é prático, pois não se pode usar um padrão de corte 1,33 vezes.
* Para converter isso em uma solução inteira (ex: x = (1, 3, 3)), o método usa uma "Heurística Residual".
* Como funciona a heurística:
    1.  Ela pega a solução fracionária x* e a ordena do valor mais alto para o mais baixo.
    2.  Começando pelo padrão mais usado (ex: x_3 = 3,5), ela o arredonda para o inteiro mais próximo (ex: 4).
    3.  Ela verifica se esse arredondamento causa "excesso" (produz mais itens do que o demandado). Se causar (como no exemplo, onde 4 usos produziriam 8 itens, mas a demanda era 7), ela reduz o valor em 1 (de 4 para 3).
    4.  Ela faz isso para os outros padrões na solução, obtendo uma primeira solução inteira aproximada w (ex: w = (1, 3, 3)).
    5.  Essa solução w provavelmente não atende a *toda* a demanda original. O algoritmo então calcula a demanda residual r (o que ainda falta produzir).
    6.  O processo todo (Passos 2 a 5) é repetido, mas agora usando essa nova demanda residual r.
    7.  Isso continua em um loop até que a demanda residual seja zero, significando que todos os itens foram produzidos.

Em resumo, o método combina a Geração de Colunas (para lidar com o número massivo de padrões) com o Problema da Mochila (para encontrar novos padrões) e uma Heurística Residual (para transformar a solução fracionária em uma solução inteira e viável).